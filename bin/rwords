#!/usr/bin/perl -w

use strict;
use utf8::all;
use utf8;
use open qw(:std :utf8);
use LWP::Simple;
use URI::Escape;
use Term::ReadLine;
use BerkeleyDB;
use XML::LibXML;
use HTML::TokeParser;
use MIME::Base64;
use Encode;
use Term::ANSIColor qw(:constants);
use POSIX qw(strftime round);
use LWP::UserAgent;
use Time::Local;
use File::Lockfile;

use vars qw(%gradeDB %dictDB %testDB %examDB $k $v) ;

my $homeDir = $ENV{RWORDS};
my $dataDir = "$homeDir/data";
my $tmpDir = "$homeDir/tmp";
my %dict = ();
my @wordList = ();
my $maxId = 0;
my $maxExamId = 0;
my $curWord;
my $curExam;
my $term;
my @testList = ();
my $curTT;
my $pid;
my $tmpfile;
my $question = "？";

my $lockfile = File::Lockfile->new("lockfile", $tmpDir);
if (my $pid = $lockfile->check) {
    print "rwords is locked.\n";
    exit;
}

sub LockRwords {
    my @list = `ps -ef | grep rwords`;
    my $i = 0;
    while (my $txt = shift @list) {
       chop($txt);
       if ($txt =~ /perl/) {
           $i = $i + 1;
       }
    }
    if ($i > 1) {
        print "too many rwords.\n";
        return 0;
    }
    $lockfile->write;
    return 1;
}

sub UnlockRwords {
    $lockfile->remove;
}

sub ExecView {
    my $pid = fork();
    if ($pid == 0) {
        exec "less", $tmpfile;
    }
    while ($pid == waitpid($pid, 0)) {
    }
}

sub CreateTmp {
    $tmpfile = "$tmpDir/$pid";
    open(F, ">$tmpfile");
}

sub CloseTmp {
    close(F);
}

sub RemoveTmp {
    if (defined $tmpfile) {
        unlink($tmpfile);
        undef $tmpfile;
    }
}

sub PrintErr {
    my $msg = shift @_;
    print BOLD, RED, $msg, RESET, "\n";
}

sub DecodeST {
    my $txt = shift @_;
    $_ = $txt;
    my @list = split(/\n|\r/);

    $txt = "";
    while (my $s = shift @list) {
        $s =~ s/^\s+|\s+$//g;
        $s =~ s/^\[//;
        $s =~ s/]$//;
        $s =~ s/^\s+|\s+$//g;
        if ($s ne "") {
            if ($txt eq "") {
                $txt = $s;
            }
            else {
                $txt = "$txt $s";
            }
        }
    }
    return $txt;
}

sub DecodeXML {
    my $txt = shift @_;
    $txt =~ s/&#39;/\'/g;
    return $txt;
}

sub ExtractWord {
    my $word = shift @_;
    my $ext;
    my $stop_trans;
    if ($word =~ /([^\|]+)\|(.+)/) {
        $word = $1;
        $ext = $2;
    }
    elsif ($word =~ /([^\\]+)\\(.+)/) {
        $word = $1;
        $ext = $2;
        $stop_trans = 1;
    }
    $word =~ s/^\s+|\s+$//g;
    my $url = "http://dict.youdao.com/w/eng/$word/#keyfrom=dict2.index";
    my %result = ();
    $result{w} = $word;

    my $ua = LWP::UserAgent->new;
    $ua->timeout(3);
    $ua->env_proxy;
    $ua->agent("Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.168 Safari/537.36");
    $ua->default_headers->push_header('Accept-Language' => "zh-CN,zh;q=0.9");
    $ua->default_headers->push_header('Accept-Encoding' => "deflate");
    $ua->default_headers->push_header('Accept' => "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8");
    $ua->default_headers->push_header('Accept-Charset' => "UTF-8");
    my $response = $ua->get($url);
    if (!$response->is_success) {
        print $response->status_line, "\n";
        undef;
        return;
    }
    my $rawHTML = decode_utf8($response->content);

    my $tp = HTML::TokeParser->new(\$rawHTML) || die "Can't open: $!";

    # 1 = get pronounce
    # 2 = get $phonetic
    # 3 = get trans content
    my $step = 0;
    my $pronounce = 0; #1 = 英; 2 = 美
    my $phonetic = "";
    my $pcount;
    my $span = 0;
    my $demo;

    if (defined $ext) {
        my @trans = ();
        push @trans, $ext;
        $result{trans} = \@trans;
    }
    while (my $token = $tp->get_token) {
        my $class;
        my $ttype = shift @{ $token };

        if ($ttype eq "S") {
            my($tag, $attr, $attrseq, $rawtxt) = @{ $token };
            if ($tag eq "span") {
                $span = 1;
            }

            if ($step == 0) {
                if ($tag eq "span") {
                    $class = $attr->{'class'} or next;
                    if ($class eq 'pronounce') {
                        $step = 1;
                        $pronounce = 0;
                        $phonetic = "";
                    }
                }
                elsif ($tag eq "div") {
                    $class = $attr->{'class'} ;
                    my $id = $attr->{'id'}; 
                    if (defined $class and $class eq "trans-container") {
                        $step = 3;
                    }
                    elsif (defined $id and $id eq "examplesToggle") {
                        $step = 5;
                    }
                }
            }
            elsif ($step == 1) {
                if ($tag eq "span") {
                    $class = $attr->{'class'} or next;
                    if ($attr->{'class'} eq 'phonetic') {
                        $step = 2;
                    }
                }
            }
            elsif ($step == 4) {
                if ($tag eq "div") {
                    my $id = $attr->{'id'} or next;
                    if ($id eq "examplesToggle") {
                        $step = 5;
                    }
                }
            }
            elsif ($step == 5) {
                if ($tag eq "ul") {
                    $step = 6;
                }
            }
            elsif ($step == 6) {
                if ($tag eq "li") {
                    $step = 7;
                    $pcount = 0;
                }
            }
            elsif ($step == 7) {
                if ($tag eq "p") {
                    $pcount = $pcount + 1;
                }
            }
        }
        elsif ($ttype eq "E") {
            my($tag, $rawtxt) = @{ $token };
            if ($tag eq "span") {
                $span = 0;
            }
            if ($step == 1) {
                $step = 0;
                if (!defined $result{pron}) {
                    my %pron = ();
                    $result{pron} = \%pron;
                }
                if ($pronounce eq 1 && $phonetic ne "") {
                    $result{pron}->{e} = $phonetic;
                }
                elsif ($pronounce eq 2 && $phonetic ne "") {
                    $result{pron}->{a} = $phonetic;
                }
            }
            elsif ($step == 2) {
                $step = 1;
            }
            elsif ($step == 3) {
                if ($tag eq "div") {
                    $step = 4;
                }
            }
            elsif ($step == 7) {
                if ($tag eq "li") {
                    $step = 6;
                    if (defined $demo) {
                        if (!defined $result{demos}) {
                            my @d = ();
                            $result{demos} = \@d;
                        }
                        push @{$result{demos}}, $demo;
                        undef $demo;
                    }
                }
            }
            elsif ($step == 6) {
                if ($tag eq "ul") {
                    last;
                }
            }
        }
        elsif ($ttype eq "T") {
            my $txt = shift @{ $token };
            if ($step == 1) {
                $txt =~ s/^\s+|\s+$//g;
                if ($txt eq "英") {
                    $pronounce = 1;
                }
                elsif ($txt eq "美") {
                    $pronounce = 2;
                }
            }
            elsif ($step eq 2) {
                $txt =~ s/^\s+|\s+$//g;
                $phonetic = $txt;
            }
            elsif ($step eq 3) {
                $txt =~ s/^\s+|\s+$//g;
                if ($txt ne "") {
                    if (!defined $result{trans}) {
                        my @trans = ();
                        $result{trans} = \@trans;
                    }
                    if ($txt =~ /以上为机器翻译结果，长、整句建议使用/) {
                        $stop_trans = 1;
                    }
                    $txt = DecodeXML($txt);
                    if (!defined $stop_trans) {
                        if ($txt =~ /^\[/) {
                            $result{st} = DecodeST($txt)
                        }
                        else {
                            push @{$result{trans}}, $txt;
                        }
                    }
                }
            }
            elsif ($step eq 7 && $pcount > 0 && $pcount < 3 && $span == 1) {
                if (!defined $demo) {
                    my @d = ();
                    $demo = \@d;
                }
                if (!defined $demo->[$pcount]) {
                    $demo->[$pcount] = ""
                }
                $demo->[$pcount] = "$demo->[$pcount]$txt";
            }
        }
    }
    $result{w2} = uri_escape_utf8($word);
    if (defined $result{trans} or defined $result{demos}) {
        return \%result;
    }
    undef;
}

sub PrintWord {
    my $word = shift @_;
    my $id = "";
    if (defined $word->{id}) {
        $id = $word->{id};
    }
    print "[$id] $word->{w}\n";

    if (defined $word->{pron}) {
        my $h;
        if (defined $word->{pron}->{e}) {
            print "英: $word->{pron}->{e} ";
            $h = 1;
        }
        if (defined $word->{pron}->{a}) {
            print "美: $word->{pron}->{a}";
            $h = 1;
        }
        if ($h) {
            print "\n\n";
        }
    }
    if (defined $word->{trans}) {
        while (my($index, $txt) = each @{$word->{trans}}){
            print "$txt\n";
        }
        print "\n";
    }
    if (defined $word->{st}) {
        print $word->{st}, "\n\n";
    }
    if (defined $word->{demos}) {
	my $i = 1;
        while (my($index, $demo) = each @{$word->{demos}}){
            if (defined $demo->[1] && defined $demo->[2]) {
                print "[$i] $demo->[1]\n";
                print "$demo->[2]\n\n";
                $i = $i + 1;
            }
        }
    }

    if (defined $word->{ct}) {
        my $ct = $word->{ct};
        my $g = $word->{g};
        my $ii = $word->{i};
        my $r = $word->{r};
        my $e = $word->{e};
        my $nt = $word->{nt};
        my $tt = $word->{tt};
        print "ct=$ct g=$g nt=$nt i=$ii r=$r e=$e tt=$tt\n";
    }
    PlaySound($word);
}

sub EscXmlStr {
    my $str = shift @_;
    $str =~ s/\</&lt;/g;
    $str =~ s/\>/&gt;/g;
    $str =~ s/\&/&amp;/g;
    $str =~ s/\'/&apos;/g;
    $str =~ s/\"/&quot;/g;
    return $str;
}

# <w id="" s="">
#  <p e="", a=""/>
#  <t c="aaaaaaaaa"/>
#  <d e="aaaaaaaaa", c="aaaaaaaaaaaaaa"/>
# </w>
sub SaveToXml {
    my $word = shift @_;
    my $xml = "<w id=\"$word->{id}\" ct=\"$word->{ct}\">";
    my $t;
    if (defined $word->{pron}) {
        my $s = "";
        if (defined $word->{pron}->{e}) {
            $t = EscXmlStr($word->{pron}->{e});
            $s = "$s e=\"$t\"";
        }
        if (defined $word->{pron}->{a}) {
            $t = EscXmlStr($word->{pron}->{a});
            $s = "$s a=\"$t\"";
        }
        if ($s ne "") {
            $xml = "$xml<p$s/>"
        }
    }
    if (defined $word->{trans}) {
        while (my($index, $txt) = each @{$word->{trans}}) {
            $txt = EscXmlStr($txt);
            $xml = "$xml<t c=\"$txt\"/>";
        }
    }

    if (defined $word->{st}) {
        my $txt = EscXmlStr($word->{st});
        $xml = "$xml<st c=\"$txt\"/>";
    }
    if (defined $word->{demos}) {
        while (my($index, $demo) = each @{$word->{demos}}){
            if (defined $demo->[1] && defined $demo->[2]) {
                my $e = EscXmlStr($demo->[1]);
                my $c = EscXmlStr($demo->[2]);
                $xml = "$xml<d e=\"$e\" c=\"$c\"/>";
            }
        }
    }
    $xml = "$xml</w>";
    return $xml;
}

sub LoadFromXml {
    my $txt = shift @_;
    my $xml = shift @_;
    my $doc = XML::LibXML->load_xml(string => $xml);

    my %word = ();
    $word{w} = $txt;
    for my $node ($doc->findnodes('//w')) {
        my $id = $node->findvalue('@id');
        my $ct = $node->findvalue('@ct');
        $word{id} = $id;
        $word{ct} = $ct;
        last;
    }
    for my $node ($doc->findnodes('//w/p')) {
        my $e = $node->findvalue('@e');
        my $a = $node->findvalue('@a');
        if (!defined $e || !defined $a) {
            last;
        }
        my %pron = ();
        $word{pron} = \%pron;
        if (defined $e) {
            $pron{e} = $e;
        }
        if (defined $a) {
            $pron{a} = $a;
        }
        last;
    }

    for my $node ($doc->findnodes('//w/t')) {
        if (!defined $word{trans}) {
            my @list = ();
            $word{trans} = \@list;
        }
        my $c = $node->findvalue('@c');
        push @{$word{trans}}, $c;
    }

    for my $node ($doc->findnodes('//w/st')) {
        $word{st} = $node->findvalue('@c');
        last;
    }

    for my $node ($doc->findnodes('//w/d')) {
        if (!defined $word{demos}) {
            my @list = ();
            $word{demos} = \@list;
        }
        my @demo = ();
        $demo[1] = $node->findvalue('@e');
        $demo[2] = $node->findvalue('@c');
        push @{$word{demos}}, \@demo;
    }
    $word{w2} = uri_escape($txt);
    return \%word;
}

sub SaveToDB {
    my $word = shift @_;
    my $dictWord = $dict{$word->{w}};

    if (defined $dictWord) {
        $word->{id} = $dictWord->{id};
        $dict{$word->{w}} = $word;
    }
    else {
        $maxId = $maxId + 1;
        $word->{id} = $maxId;
    }
    if (!defined $word->{ct}) {
        $word->{ct} = GetDay();
    }
    $wordList[$word->{id}] = $word;
    $dict{$word->{w}} = $word;
    $dictDB{$word->{w}} = SaveToXml($word);
    LoadGrade($word);
    return $word;
}

sub GetSoundPath {
    my $word = shift @_;
    my $s = substr($word->{w}, 0, 1);
    my $s2 = uri_escape($word->{w});
    return "$homeDir/sound/$s/$s2.mp3";
}

sub SaveSound {
    my $word = shift @_;
    my $filename = shift @_;
    if (!defined $filename) {
        my $s = substr($word->{w}, 0, 1);
        my $s2 = uri_escape_utf8($word->{w});
        my $path = "$homeDir/sound/$s";
        $filename = "$path/$s2.mp3";
        `mkdir -p "$path"`;
    }
    my $url = "http://dict.youdao.com/dictvoice?audio=$word->{w2}&type=1";
    `wget -q -O "$filename" "$url"`;
}

sub PlaySound {
    my $word = shift @_;
    if (defined $word->{id}) {
        my $fname = GetSoundPath($word);
        if (!-e $fname) {
            SaveSound($word);
        }
        `mpg123 -q "$fname"`;
        my $c = $? >> 8;
        if ($c != 0) {
            SaveSound($word);
            `mpg123 -q "$fname"`;
        }
    }
    else {
        my $fname = "$tmpDir/audio.mp3";
        SaveSound($word, $fname);
        #my $url = "http://dict.youdao.com/dictvoice?audio=$word->{w2}&type=1";
        #my $cmd = "mpg123 -q \"$url\"";
        #`$cmd`;
        `mpg123 -q "$fname"`;
        unlink($fname);
    }
}

sub NormWord {
    my $word = shift @_;
    $word = lc($word);
    $word =~ s/^\s+|\s+$//g;
    $word =~ s/\s\s*/ /g;
    return $word;
}

sub NormItem {
    my $txt = shift @_;
    $txt =~ s/it's/it is/g;
    $txt =~ s/she's/she is/g;
    $txt =~ s/he's/he is/g;
    $txt =~ s/i'am/i am/g;
    $txt =~ s/they're/they are/g;
    $txt =~ s/you're/you are/g;
    $txt =~ s/isn't/is not/g;
    $txt =~ s/aren't/are not/g;
    $txt =~ s/don't/do not/g;
    $txt =~ s/doesn't/does not/g;
    $txt =~ s/didn't/did not/g;
    $txt =~ s/can't/can not/g;
    $txt =~ s/wouldn't/would not/g;

    return $txt;
}


sub GetDay {
    return int(strftime("%y%m%d", localtime(time())));
}

sub AddDay {
    my $day = shift;
    my $n = shift;
    my $y = int($day / 10000);
    my $m = int(($day % 10000) / 100) - 1;
    my $d = $day % 100;

    my $t = timelocal(0, 0, 12, $d, $m, $y);
    return int(strftime("%y%m%d", localtime($t + (3600 * 24 * $n))));
}

sub LoadWord {
    my $word = shift @_;
    $word = NormWord($word);
    if ($word eq "") {
        return;
    }
    return ExtractWord($word);
}

sub LookWord {
    my $s = NormWord(shift @_);
    my $word = $dict{$s};
    undef $curWord;
    if (!defined $word) {
        $word = LoadWord($s);
    }
    if ($word) {
        PrintWord($word);
        $curWord = $word;
    }
}

sub LoadGrade {
    my $word = shift @_;
    my $grade = $gradeDB{$word->{w}};
    if (defined $grade) {
        my @list = split(/,/, $grade);
        $word->{g} = $list[0];
        $word->{r} = $list[1];
        $word->{i} = $list[2];
        $word->{e} = $list[3];
        $word->{tt} = $list[4];
        $word->{nt} = $list[5];
    }
    else {
        $word->{g} = 0;
        $word->{r} = 0;
        $word->{i} = 0;
        $word->{e} = 2.5;
        $word->{tt} = 0;
        $word->{nt} = 0;
    }
}

sub SaveGrade {
    my $word = shift @_;
    $gradeDB{$word->{w}} = "$word->{g},$word->{r},$word->{i},$word->{e},$word->{tt},$word->{nt}\n";
}

sub CreateExam {
    my $train = shift @_;
    my @list = ();
    my $i = 1;
    my $count = 0;
    my $today = GetDay();
    my %result = ();

    if (!defined $train) {
        $train = 0;
    }

    while ($i <= $maxId) {
        if (defined $wordList[$i]) {
            my $word = $wordList[$i];
            if (($train == 0 && ($word->{g} <= 2 || $word->{nt} <= $today || $word->{tt} == $today)) ||
                ($train == 1 && $word->{tt} == 0) ||
                ($train == 2 && $word->{ct} == $today)) {
                $count = $count + 1;
                push @list, $word;
            }
        }
        $i = $i + 1;
    }

    srand(time());
    my @list2 = ();
    while (1) {
        my $size = @list;
        if ($size < 1) {
            last;
        }
        my $index = int(rand($size));
        if ($index < 0) {
            $index = 0;
        }
        if ($index >= $size) {
            $index = $size - 1;
        }

        my $word = $list[$index];
        splice(@list, $index, 1);
        push @list2, $word;
    }

    my @list3 = ();
    $result{list} = \@list2;
    $result{start} = time();
    $result{end} = time();
    $result{count} = $count;
    $result{cur} = 0;
    $result{ec} = 0;
    $result{result} = \@list3;
    $result{day} = $today;
    if ($train != 0) {
        $result{tmp} = 1;
    }
    return \%result;
}

sub CloseExam {
    undef $curExam;
    UnlockRwords;
}

sub PrintExam {
    my $word = $curExam->{list}->[$curExam->{cur}];
    my $i = $curExam->{cur} + 1;
    my $cz = "单词";
    if ($word->{w} =~ /\s/) {
        $cz = "词组";
    }
    system 'clear';
    print BOLD, BLUE, "[$i/$curExam->{count}]$cz-------------------------------", RESET, "\n";

    if (defined $word->{trans}) {
        print GREEN;
        while (my($index, $txt) = each @{$word->{trans}}){
            $txt = lc($txt);
            $txt = DecodeXML($txt);
            if ($txt ne $word->{w}) {
                $txt =~ s/$word->{w}//g;
                print "$txt\n";
            }
        }
        print RESET, "\n";
    }

    if (defined $word->{demos}) {
        print YELLOW;
        while (my($index, $demo) = each @{$word->{demos}}){
            if (defined $demo->[1] && defined $demo->[2]) {
                my $txt = $demo->[2];
                $txt = lc($txt);
                $txt =~ s/$word->{w}//g;
                print "$txt\n";
            }
        }
        print RESET, "\n";
    }
}

sub PrintExamList {
    my $txt = shift @_;
    my $all = shift @_;
    
    my @list = split(/\n/, $txt);

    while (my $line = shift @list) {
        my @elems = split(/\|/, $line);
        if ($elems[1] < 2 && !defined $all) {
            next;
        }

        print "$elems[0], ec=$elems[1], using=$elems[2]s\n"; 
    }
}

sub CalcExam {
    my @ec = (0, 0, 0, 0);
    my $day = $curExam->{day};
    my $txtExam = "";
    while (my $r = shift @{$curExam->{result}}) {
        $ec[$r->{ec}] = $ec[$r->{ec}] + 1;
        my $word = $r->{w};
        $txtExam = "$txtExam$word->{w}|$r->{ec}|$r->{time}\n";
        if ($word->{tt} >= $day) {
            next;
        }

        if (!defined $curExam->{tmp}) {
            if ($r->{ec} == 0 || $r->{ec} == 1) {
                if ($word->{g} < 5) {
                    $word->{g} = $word->{g} + 1;
                }
            }
            elsif ($r->{ec} == 2) {
                next;
            }
            else {
                $word->{g} = 0;
                $word->{r} = 0;
                $word->{i} = 0;
                $word->{e} = 2.5;
                $word->{nt} = 0;
            }

            if ($word->{g} >= 2) {
                if ($word->{r} == 0) {
                    $word->{i} = 1;
                    $word->{r} = 1;
                }
                elsif ($word->{r} == 1) {
                    $word->{i} = 6;
                    $word->{r} = 2;
                }
                else {
                    $word->{i} = round($word->{i} * $word->{e});
                    $word->{r} = $word->{r} + 1;
                }
            }
            else {
                $word->{r} = 0;
                $word->{i} = 1;
            }

            if ($word->{g} > 0) {
                $word->{e} = $word->{e} + (0.1 - (5 - $word->{g}) * (0.08 + (5 - $word->{g}) * 0.02));

                if ($word->{e} < 1.3) {
                    $word->{e} = 1.3;
                }
            }

            $word->{nt} = AddDay($day, $word->{i});
            $word->{tt} = $day;
            SaveGrade($word);
        }
=pod
        if Grade>=3 then begin
            if Repetition=0 then begin
                Interval:=1;
                Repetition:=1;
            end
            else if Repetition=1 then begin
                Interval:=6;
                Repetition:=2;
            end
            else begin
                Interval:=round(Interval*EF);
                Repetition:=Repetition+1;
            end;
        end
        else begin
            Repetition:=0;
            Interval:=1;
        end;
        EF:=EF+(0.1-(5-Grade)*(0.08+(5-Grade)*0.02));
        if EF<1.3 then
            EF:=1.3;
        NextInterval:=Interval;
=cut
    }

    if ($curExam->{count} == 0) {
        return;
    }
    my $t = $curExam->{end} - $curExam->{start};
    my $m = int($t / 60);
    my $s = $t - $m * 60;
    my $start = strftime("%y-%m-%d %H:%M", localtime($curExam->{start}));
    my $r1c = $ec[0] + $ec[1];
    my $r1 = int($r1c * 10000 / $curExam->{count}) / 100;
    my $r2 = int($ec[2] * 10000 / $curExam->{count}) / 100;
    my $r3 = int($ec[3] * 10000 / $curExam->{count}) / 100;
    my $txt = "Time: $start, Using: $m" . "m" . "$s" . "s, \tR1: $r1%($r1c), \tR2: $r2%($ec[2]), \tR3: $r3%($ec[3])";
    if (!defined $curExam->{tmp}) {
        my $id = $maxExamId + 1;
        $maxExamId = $id;
        $testDB{$id} = $txt;
        $examDB{$id} = $txtExam;
        $testList[$id] = $txt;
    }
    print "$txt\n";
    PrintExamList($txtExam);
}

sub NextWord {
    my $word = $curExam->{list}->[$curExam->{cur}];
    my %r = ();
    my $t = time();
    $r{time} = $t - $curExam->{end};
    $curExam->{end} = $t;
    $r{ec} = $curExam->{ec};
    $r{w} = $word;

    if ($r{ec} != 3) {
        PlaySound($word);
    }
    else {
        PrintWord($word);
        if ($curExam->{cur} < $curExam->{count} - 1) {
            $curExam->{wait} = 1;
            PrintErr("The word test is failed, press enter key to continue the test.");
            $term->readline('');
        }
        else {
            PrintErr("The word test is failed.\n");
        }
    }

    push @{$curExam->{result}}, \%r;

    $curExam->{cur} = $curExam->{cur} + 1;
    $curExam->{ec} = 0;
    if ($curExam->{cur} < $curExam->{count}) {
        PrintExam();
    }
    else {
        CalcExam();
        print "The exam is finished.\n";
        CloseExam;
    }
}

sub CheckExam {
    my $txt = shift @_;
    
    if (defined $txt or $txt ne "") {
        if ($txt eq "/gg") {
            $curExam->{ec} = 3;
            NextWord();
            return;
        }
        my $word = $curExam->{list}->[$curExam->{cur}];
        if (NormItem($txt) eq NormItem(lc($word->{w}))) {
            NextWord();
        }
        else {
            $curExam->{ec} = $curExam->{ec} + 1;
            if ($curExam->{ec} < 3) {
                PrintErr("The input is wrong.\n");
            }
            else {
                NextWord();
            }
        }
    }
    else {
        PrintExam();
    }
}

my @tts = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
           ' ', ',', '.', ';', "'");
my @ttf = ('e', 'b', 'c', 'c', 'c', 'b', 'b', 'B', 'C', 'B', 'C', 'D', 'B', 'B', 'D', 'E', 'e', 'b', 'd', 'b', 'B', 'b', 'd', 'd', 'B', 'e',
           'a', 'C', 'D', 'E', 'E');
sub MakeTT {
    system 'clear';
    my @list1 = ();
    my @list2 = ();
    my $i = 0;
    while (1) {
        if (!defined $tts[$i]) {
            last;
        }
        push(@list1, $tts[$i]);
        push(@list2, $ttf[$i]);
        $i = $i + 1;
    }
    srand(time());
    my $step = 0;
    my $ks = "";
    my $fs = "";
    my $fk;
    my $ff;
    my $lk;
    my $lf;
    while ($i > 0) {
        my $index = int(rand($i));
        if ($index < 0) {
            $index = 0;
        }
        if ($index >= $i) {
            $index = $i - 1;
        }

        if ((!defined $fk or !defined $lk) and $list1[$index] eq " ") {
            next;
        }
        
        if (!defined $fk) {
            $fk = $list1[$index];
            $ff = $list2[$index];
        }
        elsif (!defined $lk) {
            $lk = $list1[$index];
            $lf = $list2[$index];
        }
        else {
            $ks = $ks . $list1[$index];
            $fs = $fs . $list2[$index];
        }

        if ($index != $i - 1) {
            $list1[$index] = $list1[$i - 1];
            $list2[$index] = $list2[$i - 1];
        }
        $i = $i - 1;
    }
    
    $curTT = "$fk$ks$lk";
    print BOLD, GREEN, "    $fk$ks$lk", RESET, "\n";
    print "    $ff$fs$lf\n";
}

sub CheckTT {
    my $txt = shift @_;
    if ($txt ne $curTT) {
        PrintErr("The input is wrong.\n");
    }
    else {
        MakeTT();
    }
}

sub Exit {
    exit;
}

sub HandleLoad {
    my ($txt) = @_;
    if (!defined $txt) {
        print "bad args.\n";
        return;
    }
    $txt = NormWord($txt);
    if ($txt eq "") {
        print "bad args.\n";
        return;
    }

    undef $curWord;
    my $word = ExtractWord($txt);
    if (defined $word) {
        PrintWord($word);
        $curWord = $word;
    }
    return $word;
}

sub HandleSearch {
    my $txt = shift @_;

    my $i = 1;
    while ($i <= $maxId) {
        if (defined $wordList[$i]) {
            if ($wordList[$i]->{w} =~ /$txt/) {
                print "$i\t$wordList[$i]->{w}\n";
            }
        }
        $i = $i + 1;
    }
}

sub HandleSave {
    if (defined $curWord) {
    	if (!LockRwords) {
	    undef;
            return;
    	}	
        SaveToDB($curWord);
        SaveSound($curWord);
	UnlockRwords();
        print "Save '$curWord->{w}', id is '$curWord->{id}'.\n";

        my $tmp = $curWord;
        undef $curWord;
        return $tmp;
    }
    print "No word to save.\n";
    undef;
}

sub HandleReplace {
    my $id = shift @_;
    if (defined $curWord) {
    	if (!LockRwords) {
	    undef;
            return;
    	}	
        SaveToDB($curWord);
        SaveSound($curWord);
	UnlockRwords();
        HandleDelete($id);
        print "Save '$curWord->{w}', id is '$curWord->{id}'.\n";

        my $tmp = $curWord;
        undef $curWord;
        return $tmp;
    }
    print "No word to save.\n";
    undef;
}

sub HandlePrint {
    my $txt = shift @_;
    my $word;
    if (!defined $txt) {
        $word = $curWord;
    }
    elsif ($txt =~ /^[0-9]+$/) {
        $word = $wordList[$txt];
    }
    else {
        $txt = NormWord($txt);
        $word = $dict{$txt};
    }
    if ($word) {
        PrintWord($word);
    }
}

sub HandleList {
    my $who = shift @_;
    if (!defined $who) {
        $who = "word";
    }

    my $count = 0;

    if ($who eq "word") {
        my $i = 1;
        while ($i <= $maxId) {
            if (defined $wordList[$i]) {
                my $ct = $wordList[$i]->{ct};
                my $g = $wordList[$i]->{g};
                my $ii = $wordList[$i]->{i};
                my $r = $wordList[$i]->{r};
                my $e = $wordList[$i]->{e};
                my $nt = "$wordList[$i]->{nt}";
                my $tt = $wordList[$i]->{tt};
                print "$i\t$wordList[$i]->{w} ct=$ct g=$g nt=$nt i=$ii r=$r e=$e tt=$tt\n";
                $count = $count + 1;
            }
            $i = $i + 1;
        }
    }
    elsif ($who eq "test") {
        my $i = 1;
        while ($i <= $maxExamId) {
            if (defined $testList[$i]) {
                print "$i\t$testList[$i]\n";
                $count = $count + 1;
            }
            $i = $i + 1;
        }
    }
    elsif ($who eq "today") {
        my $today = GetDay();
        my $i = 1;
        while ($i <= $maxId) {
            if (defined $wordList[$i]) {
                my $ct = $wordList[$i]->{ct};
                if ($ct == $today) {
                    print "$i\t$wordList[$i]->{w}\n";
                    $count = $count + 1;
                }
            }
            $i = $i + 1;
        }
    }
    elsif ($who eq "td") {
        my $today = GetDay();
        my $i = 1;
        CreateTmp();
        while ($i <= $maxId) {
            if (defined $wordList[$i]) {
                my $ct = $wordList[$i]->{ct};
                if ($ct == $today) {
                    my $word = $wordList[$i];
                    print F "$i\t$word->{w}\n";
                    if (defined $word->{trans}) {
                        while (my($index, $txt) = each @{$word->{trans}}){
                            if (!($word->{w} =~ /$txt/)) {
                                print F "\t$txt\n";
                            }
                        }
                    }
                    $count = $count + 1;
                }
            }
            $i = $i + 1;
        }
        print F "total is $count.\n";
        CloseTmp();
        ExecView();
        RemoveTmp();
        return;
    }
    elsif ($who =~ /-[0-9]+/) {
        my $today = GetDay() + $who;
        my $i = 1;
        while ($i <= $maxId) {
            if (defined $wordList[$i]) {
                my $ct = $wordList[$i]->{ct};
                if ($ct == $today) {
                    print "$i\t$wordList[$i]->{w}\n";
                    $count = $count + 1;
                }
            }
            $i = $i + 1;
        }
    }
    print "total is $count.\n";
}

sub HandleRemoveSentence {
    my $count = 0;
    my $i = 1;
    while ($i <= $maxId) {
        if (defined $wordList[$i]) {
            my $s = $wordList[$i]->{w};
            if ($s =~ /\?$|\？$|\.$/) {
                if ($s =~ /sb.$|sth.$/) {
                }
                else {
                    my $ct = $wordList[$i]->{ct};
                    my $g = $wordList[$i]->{g};
                    my $ii = $wordList[$i]->{i};
                    my $r = $wordList[$i]->{r};
                    my $e = $wordList[$i]->{e};
                    my $nt = $wordList[$i]->{nt};
                    my $tt = $wordList[$i]->{tt};
                    print "$i\t$wordList[$i]->{w} ct=$ct g=$g nt=$nt i=$ii r=$r e=$e tt=$tt\n";
                    HandleDelete($s);
                    $count = $count + 1;
                }
            }
        }
        $i = $i + 1;
    }
    print "total is $count.\n";
}

sub HandleReplaceItem {
    my $txt = shift @_;
    if (!defined $txt or $txt eq "") {
        return;
    }
    if ($txt == 0) {
	return;
    }
    if (!defined $curWord) {
        return;
    }

    if (defined $curWord->{demos}) {
        my $demo = $curWord->{demos}[$txt - 1];
        if (defined $demo && defined $demo->[2]) {
            my @trans = ($demo->[2]);
            $curWord->{trans} = \@trans;
            PrintWord($curWord);
	}
    }
}

sub HandleAddQuestion {
    if (!defined $curWord) {
        return;
    }
    my $txt = $curWord->{trans}[0];
    if (defined $txt && !($txt =~ /$question$/)) {
        my @trans = ("$txt$question");
        $curWord->{trans} = \@trans;
        PrintWord($curWord);
    }
}

sub HandleRC {
    my $txt = shift @_;
    if (!defined $txt or $txt eq "") {
        return;
    }
    if (!defined $curWord) {
        return;
    }
    my @trans = ($txt);
    $curWord->{trans} = \@trans;
    PrintWord($curWord);
}

sub HandleAC {
    my $txt = shift @_;
    if (!defined $txt or $txt eq "") {
        return;
    }
    if (!defined $curWord) {
        return;
    }
    my @trans = ($txt);
    if (defined $curWord->{trans}) {
        push @trans, @{$curWord->{trans}};
    }
    $curWord->{trans} = \@trans;
    PrintWord($curWord);
}

sub HandleRepeat {
    if (!defined $curWord) {
        return;
    }
    LookWord($curWord->{w});
}

sub HandleDelete {
    my $txt = shift @_;
    my $word;
    if ($txt =~ /^[0-9]+$/) {
        $word = $wordList[$txt];
    }
    else {
        $txt = NormWord($txt);
        $word = $dict{$txt};
    }
    if ($word) {
    	if (!LockRwords) {
	    undef;
            return;
    	}	
        delete $dictDB{$word->{w}};
        delete $dict{$word->{w}};
        delete $wordList[$word->{id}];
	UnlockRwords();
    }
}

sub HandleTest {
    if (!LockRwords) {
        return;
    }
    my $exam = CreateExam();
    if ($exam->{count} < 1) {
        print "The exam is empty.\n";
        return;
    }
    $curExam = $exam;
    PrintExam();
}

sub HandleShow {
    my $who = shift @_;
    my $arg = shift @_;
    if (!defined $who || !defined $arg) {
        return;
    }

    if ($who eq "test") {
        if (not $arg =~ /[0-9]+/) {
            return;
        }
        if (!defined $testList[$arg]) {
            return;
        }
        my $txt = $examDB{$arg};
        print $testList[$arg], "\n";
        PrintExamList($txt);
    }
    elsif ($who eq "exam") {
        if (not $arg =~ /[0-9]+/) {
            return;
        }
        if (!defined $testList[$arg]) {
            return;
        }
        PrintExamList($examDB{$arg}, 1);
    }
}

sub HandleTrain {
    my $exam = CreateExam(1);
    if ($exam->{count} < 1) {
        print "The exam is empty.\n";
        return;
    }
    $curExam = $exam;
    PrintExam();
}

sub HandleToday {
    my $exam = CreateExam(2);
    if ($exam->{count} < 1) {
        print "The exam is empty.\n";
        return;
    }
    $curExam = $exam;
    PrintExam();
}

sub HandleTestWords {
    my $exam = CreateExam();
    my $i = 1;
    while (1) {
        my $word = $exam->{list}->[$i];
        if (!defined $word) {
            last;
        }
        my $ct = $word->{ct};
        my $g = $word->{g};
        my $ii = $word->{i};
        my $r = $word->{r};
        my $e = $word->{e};
        my $nt = $word->{nt};
        my $tt = $word->{tt};
        print "$i\t$word->{w} ct=$ct g=$g nt=$nt i=$ii r=$r e=$e tt=$tt\n";
        $i = $i + 1;
    }
    print "$exam->{count} $i\n"; 
}

sub MTime {
    my $t = shift;
    $t = strftime("%y%m%d", localtime($t * 3600 * 24));
    return int($t);
}

sub HandleMigrate {
=pod
    my $i = 1;
    while ($i <= $maxId) {
        if (defined $wordList[$i]) {
            my $word = $wordList[$i];
            $word->{ct} = MTime($word->{ct});
            $word->{nt} = MTime($word->{nt});
            $word->{tt} = MTime($word->{tt});
            SaveGrade($word);
            SaveToDB($word);
            if ($word->{nt} > 180530) {
                print "$i\n";
            }
        }
        $i = $i + 1;
    }
=cut
}

sub HandleSearchWord {
    my $txt = shift;
    $txt =~ s/^\s+|\s+$//g;
    if ($txt eq "") {
        return;
    }
    my $i = 1;
    my $found = 0;
    while ($i <= $maxId) {
        if (defined $wordList[$i]) {
            if ($wordList[$i]->{w} =~ /$txt/) {
                print "$i\t$wordList[$i]->{w}\n";
                $found = 1;
            }
        }
        $i = $i + 1;
    }
    if ($found) {
        return;
    }

    HandleLoad($txt);
}

sub HandleTouch {
    my $txt = shift @_;
    if (!defined $txt or $txt eq "") {
        return;
    }
    my $word;
    if ($txt =~ /[0-9]+/) {
        $word = $wordList[$txt];
    }
    else {
        $txt = NormWord($txt);
        $word = $dict{$txt};
    }
    if (!defined $word) {
        return;
    }

    if (!LockRwords) {
        undef;
        return;
    }	

    $word->{g} = 0;
    $word->{r} = 0;
    $word->{i} = 0;
    $word->{e} = 2.5;
    $word->{nt} = 0;
    SaveGrade($word);

    UnlockRwords();

    HandlePrint($word->{id});
}

sub HandleCmd {
    my $cmd = shift @_;
    my $argstr = shift @_;
    my @args = ();

    if ($cmd =~ /^\/(.*)/) {
        HandleSearchWord($1);
        return;
    }
    while ($argstr ne "") {
        $argstr =~ s/^\s+//;
        if ($argstr =~ s/^\"([^\"]*)\"//) {
            push @args, $1;
        }
        elsif ($argstr =~ s/^([^\"\s]+)//) {
            push @args, $1;
        }
        else {
            if ($argstr ne "") {
                push @args, $argstr;
            }
            last;
        }
    }

    if ($cmd eq "quit") {
        if (defined $curTT) {
            undef $curTT;
        }
        else {
            Exit;
        }
    }
    elsif ($cmd eq "r") {
        HandleRepeat();
    }
    elsif ($cmd eq "load") {
        HandleLoad(@args);
    }
    elsif ($cmd eq "save") {
        HandleSave(@args);
    }
    elsif ($cmd eq "print") {
        HandlePrint(@args);
    }
    elsif ($cmd eq "list") {
        HandleList(@args);
    }
    elsif ($cmd eq "search") {
        HandleSearch(@args);
    }
    elsif ($cmd eq "delete") {
        HandleDelete(@args);
    }
    elsif ($cmd eq "replace") {
        HandleReplace(@args);
    }
    elsif ($cmd eq "test") {
        HandleTest(@args);
    }
    elsif ($cmd eq "show") {
        HandleShow(@args);
    }
    elsif ($cmd eq "train") {
        HandleTrain(@args);
    }
    elsif ($cmd eq "today") {
        HandleToday(@args);
    }
    elsif ($cmd eq "tt") {
        MakeTT();
    }
    elsif ($cmd eq "rc") {
        HandleRC(@args);
    }
    elsif ($cmd eq "ac") {
        HandleAC(@args);
    }
    elsif ($cmd eq "testwords") {
        HandleTestWords(@args);
    }
    elsif ($cmd eq "migrate") {
        HandleMigrate(@args);
    }
    else {
        print "Unknown command '$cmd'.\n";
    }
}

my $env = new BerkeleyDB::Env
    -Home   => $dataDir,
    -Cachesize => 1024 * 1024 * 1024,
    -Flags  => DB_CREATE| DB_INIT_CDB | DB_INIT_MPOOL
or die "cannot open environment: $BerkeleyDB::Error\n";


tie (%dictDB, "BerkeleyDB::Hash",
    -Filename => 'dict.db',
    -Flags => DB_CREATE,
    -Env => $env)
|| die " Cannot open file 'dict.db':$! $BerkeleyDB::Error\n";

tie (%gradeDB, "BerkeleyDB::Hash",
    -Filename => 'sm.db',
    -Flags => DB_CREATE,
    -Env => $env)
|| die " Cannot open file 'sm.db':$! $BerkeleyDB::Error\n";

tie (%testDB, "BerkeleyDB::Hash",
    -Filename => 'test.db',
    -Flags => DB_CREATE,
    -Env => $env)
|| die " Cannot open file 'sm.db':$! $BerkeleyDB::Error\n";

tie (%examDB, "BerkeleyDB::Hash",
    -Filename => 'exam.db',
    -Flags => DB_CREATE,
    -Env => $env)
|| die " Cannot open file 'sm.db':$! $BerkeleyDB::Error\n";

while (my ($k, $v) = each %dictDB) {
    $v = decode_utf8($v);
    my $word = LoadFromXml($k, $v);
    $dict{$k} = $word;
    $wordList[$word->{id}] = $word;
    if ($maxId < $word->{id}) {
        $maxId = $word->{id};
    }
    LoadGrade($word);
}

while (my ($k, $v) = each %testDB) {
    $testList[$k] = $v;
    if ($k > $maxExamId) {
        $maxExamId = $k;
    }
}

#BEGIN {
#    import Term::ReadLine::Gnu qw(:keymap_type RL_STATE_INITIALIZED);
#}

$pid = $$;
$term = Term::ReadLine->new(0);
binmode($term->IN, ':utf8');

while (1) {
    my $prompt = "> ";
    if (defined $curTT) {
        $prompt = "TT> ";
    }
    elsif (defined $curExam) {
        $prompt = "Exam[$curExam->{ec}]> ";
    }
    if (defined ($_ = $term->readline($prompt))) {
        my $cmd = $_;
        my $orig = $cmd;
        $cmd = decode_utf8($cmd);
        $cmd =~ s/^\s+|\s+$//g;

        if ($cmd eq "") {
            next;
        }
        elsif (defined $curExam) {
            if ($cmd =~ /^\/([a-z]+)(.*)/) {
                $cmd = $1;
                my $args = $2;
                $cmd =~ s/^\s+|\s+$//g;
                if ($cmd eq "gg") {
                    CheckExam('/gg');
                }
                elsif ($cmd eq "cancel") {
                    CloseExam;
                }
            }
            else {
                CheckExam(NormWord($cmd));
            }
        }
        elsif ($cmd =~ /^\/\/(.*)/) {
            HandleSearchWord($1);
        }
	elsif ($cmd =~ /^\/ac (.+)/) {
            $cmd = $1;
            $cmd =~ s/^\s+|\s+$//g;
            HandleAC($cmd);
        }
        elsif ($cmd =~ /^\/rc (.+)/) {
            $cmd = $1;
            $cmd =~ s/^\s+|\s+$//g;
            HandleRC($cmd);
        }
        elsif ($cmd =~ /^\/([0-9]+)/) {
            $cmd = $1;
            HandleReplaceItem($cmd);
        }
        elsif ($cmd =~ /^\/\?/) {
            HandleAddQuestion();
        }
        elsif ($cmd =~ /^\/touch (.*)/) {
            $cmd = $1;
            $cmd =~ s/^\s+|\s+$//g;
            HandleTouch($cmd);
        }
        elsif ($cmd =~ /^\/([a-z]+)(.*)/) {
            $cmd = $1;
            my $args = $2;
            $cmd =~ s/^\s+|\s+$//g;
            $args =~ s/^\s+|\s+$//g;
            HandleCmd($cmd, $args);
        }
        elsif (defined $curTT) {
            CheckTT($cmd);
        }
        else {
            LookWord($cmd);
        }
        $term->addhistory($orig);
    }
}

